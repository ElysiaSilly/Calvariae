package com.elysiasilly.calvariae.common.world.feature;

import com.elysiasilly.calvariae.core.registry.CBlocks;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.world.level.WorldGenLevel;
import net.minecraft.world.level.block.Blocks;
import net.minecraft.world.level.block.DoublePlantBlock;
import net.minecraft.world.level.block.HorizontalDirectionalBlock;
import net.minecraft.world.level.block.state.properties.BlockStateProperties;
import net.minecraft.world.level.block.state.properties.DoubleBlockHalf;
import net.minecraft.world.level.levelgen.feature.Feature;
import net.minecraft.world.level.levelgen.feature.FeaturePlaceContext;
import net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration;

import java.util.HashSet;
import java.util.Set;

public class DripLeavesBasinFeature extends Feature<NoneFeatureConfiguration> {

    // TODO : move blockCanBeIgnored to a blocktag
    // TODO : features generated by worldgen have grass on them

    // TODO : unfuck the code just a smidge

    public DripLeavesBasinFeature() {
        super(NoneFeatureConfiguration.CODEC);
    }

    public boolean blockCanBeIgnored(BlockPos pos, WorldGenLevel level) {
        return
                level.getBlockState(pos).canBeReplaced() ||
                level.getBlockState(pos).is(Blocks.MOSS_CARPET) ||
                level.getBlockState(pos).is(Blocks.AZALEA) ||
                level.getBlockState(pos).is(Blocks.FLOWERING_AZALEA) ||
                level.getBlockState(pos).is(CBlocks.FLOWERING_MOSSPROUT.get()) ||
                level.getBlockState(pos).is(Blocks.CAVE_VINES) ||
                level.getBlockState(pos).is(Blocks.CAVE_VINES_PLANT) ||
                level.getBlockState(pos).is(Blocks.SMALL_DRIPLEAF) ||
                level.getBlockState(pos).is(Blocks.BIG_DRIPLEAF_STEM) ||
                level.getBlockState(pos).is(Blocks.BIG_DRIPLEAF);
    }

    public boolean isNoNoBlock(BlockPos pos, WorldGenLevel level) {
        return
                level.getBlockState(pos).isAir() ||
                level.getBlockState(pos).is(Blocks.WATER) ||
                level.getBlockState(pos).is(Blocks.LAVA);
    }

    public boolean isDisasterBlock(BlockPos pos, WorldGenLevel level) {
        return
                level.getBlockState(pos).is(Blocks.WATER) ||
                level.getBlockState(pos).is(Blocks.LAVA);
    }

    public boolean isMaybeBlock(BlockPos pos, WorldGenLevel level) {
        return
                level.getBlockState(pos).isAir() ||
                level.getBlockState(pos).is(Blocks.LAVA);
    }

    public BlockPos surface(BlockPos.MutableBlockPos mutableBlockPos, WorldGenLevel level, BlockPos floorPos, int x, int z) {

        mutableBlockPos.setWithOffset(floorPos, x, 2, z);

        if(blockCanBeIgnored(mutableBlockPos, level)) {
            for(int y = 1; y <= 3; y++) {
                if(!blockCanBeIgnored(mutableBlockPos.below(y), level)) {
                    return mutableBlockPos.below(y).immutable();
                }
            }
        }

        return floorPos;
    }

    @Override
    public boolean place(FeaturePlaceContext<NoneFeatureConfiguration> context) {

        WorldGenLevel level = context.level();
        BlockPos originPos = context.origin();

        int radius = level.getRandom().nextIntBetweenInclusive(6, 12);
        int depth = 6;
        int clampCorners = radius + 1; //radius + ((radius / 2 )/ 2);

        BlockPos floorPos = originPos;

        boolean validFloorIsPresent = floorPos != null;
        boolean containsNoNoBlock = false;

        while(blockCanBeIgnored(floorPos, level)) {
            if(level.getBlockState(floorPos).is(Blocks.WATER) || level.getBlockState(floorPos).is(Blocks.LAVA)) {
                validFloorIsPresent = false;
            }
            floorPos = floorPos.below();
        }

        BlockPos.MutableBlockPos mutableBlockPos = floorPos.mutable();

        Set<BlockPos> surface = new HashSet<>();
        Set<BlockPos> volume = new HashSet<>();

        if(validFloorIsPresent) {

            for(int x = -radius; x <= radius; ++x) {
            for(int z = -radius; z <= radius; ++z) {

                if(x * x + z * z<= clampCorners * clampCorners) {

                    int random = level.getRandom().nextIntBetweenInclusive(0, 1);

                    if(!((x == radius || -x == radius || z == radius || -z == radius) && random == 1)) {
                    surface.add(surface(mutableBlockPos, level, floorPos, x, z));

                    }
                }



            }}

            BlockPos temporary;

            for (BlockPos pos : surface) {
                temporary = pos;

                int currentY = temporary.getY();
                int baseY = floorPos.getY();
                int bottomY = baseY - depth;

                while(currentY > bottomY) {
                    if(isNoNoBlock(temporary, level) || isNoNoBlock(temporary.below(1), level)) {
                        containsNoNoBlock = true;
                    } else {
                        volume.add(temporary);
                    }

                    if (floorPos.getY() - temporary.getY() != 4) {
                        if (isDisasterBlock(temporary.west(), level) || isDisasterBlock(temporary.east(), level) || isDisasterBlock(temporary.north(), level) || isDisasterBlock(temporary.south(), level)) {
                            containsNoNoBlock = true;
                        }
                    }

                    if (floorPos.getY() - temporary.getY() == 3) {
                        if (isMaybeBlock(temporary.west(), level) || isMaybeBlock(temporary.east(), level) || isMaybeBlock(temporary.north(), level) || isMaybeBlock(temporary.south(), level)) {
                            containsNoNoBlock = true;
                        }
                    }

                    temporary = temporary.below();
                    currentY = temporary.getY();
                }
            }


            if(!containsNoNoBlock && validFloorIsPresent) {
                for (BlockPos pos : volume) {
                    temporary = pos;

                    switch (floorPos.getY() - temporary.getY()) {
                        case 5:  level.setBlock(temporary, Blocks.CLAY.defaultBlockState(), 2);  break;
                        case 4:  level.setBlock(temporary, Blocks.WATER.defaultBlockState(), 2); break;
                        //default: level.setBlock(temporary, Blocks.AIR.defaultBlockState(), 2);  break;
                        default: level.removeBlock(temporary, false);  break;
                    }
                }

                for (BlockPos pos : surface) {
                    temporary = pos;

                    int random = level.getRandom().nextIntBetweenInclusive(1, 8);

                    // TODO : bruh
                    level.removeBlock(temporary.above(1), false);
                    level.removeBlock(temporary.above(2), false);

                    //level.removeBlock()
                    if (random == 5) {
                        int randomDirection = level.getRandom().nextIntBetweenInclusive(1, 4);

                        Direction direction = switch (randomDirection) {
                            case 1 -> Direction.WEST;
                            case 2 -> Direction.SOUTH;
                            case 3 -> Direction.NORTH;
                            default -> Direction.EAST;
                        };

                        int product = temporary.getY() - floorPos.below(depth - 1).getY();

                        int randomHeightVariation = level.getRandom().nextIntBetweenInclusive(-1, 0);

                        for (int i = -randomHeightVariation; i < product; i++) {
                            setBlock(level, temporary.below(i), Blocks.BIG_DRIPLEAF_STEM.defaultBlockState()
                                    .setValue(HorizontalDirectionalBlock.FACING, direction)
                                    .setValue(BlockStateProperties.WATERLOGGED, level.isWaterAt(temporary.below(i)))
                            );
                        }

                        setBlock(level, temporary.above(randomHeightVariation), Blocks.BIG_DRIPLEAF.defaultBlockState()
                                .setValue(HorizontalDirectionalBlock.FACING, direction)
                                .setValue(BlockStateProperties.WATERLOGGED, level.isWaterAt(temporary))
                        );
                    }
                }

                for (BlockPos pos : volume) {
                    temporary = pos;

                    int random = level.getRandom().nextIntBetweenInclusive(1, 5);

                    if (random == 3) {

                        int randomDirection = level.getRandom().nextIntBetweenInclusive(1, 4);

                        Direction direction = switch (randomDirection) {
                            case 1  -> Direction.WEST;
                            case 2  -> Direction.SOUTH;
                            case 3  -> Direction.NORTH;
                            default -> Direction.EAST;
                        };

                        if(floorPos.getY() - temporary.getY() == 3) {
                            if(isNoNoBlock(temporary, level)) {
                                setBlock(level, temporary, Blocks.SMALL_DRIPLEAF.defaultBlockState()
                                        .setValue(DoublePlantBlock.HALF, DoubleBlockHalf.UPPER)
                                        .setValue(HorizontalDirectionalBlock.FACING, direction)
                                        .setValue(BlockStateProperties.WATERLOGGED, level.isWaterAt(temporary)));

                                setBlock(level, temporary.below(), Blocks.SMALL_DRIPLEAF.defaultBlockState()
                                        .setValue(DoublePlantBlock.HALF, DoubleBlockHalf.LOWER)
                                        .setValue(HorizontalDirectionalBlock.FACING, direction)
                                        .setValue(BlockStateProperties.WATERLOGGED, level.isWaterAt(temporary.below())));
                            }
                        }
                    }
                }
            }
        }

        return validFloorIsPresent && !containsNoNoBlock;
    }
}
